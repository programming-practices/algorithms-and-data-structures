package algorithms;

// Sources: https://www.youtube.com/watch?v=Ek9ijOiplNE&list=PLoij6udfBncg1yi1Hhp67WZQIUBp05F-A&index=3
//          start: 12:00  end: ...

public class AnalysisOfAlgorithms {
    public static void main(String[] args) {

    }
}


/*
------------------------------------------------------------------------------------------------------------------------
Чтобы решить, какая из них лучше подходит (realizacia algoritma) для конкретного приложения, можно использовать такой
способ: попробовать обе и посмотреть, сколько каждой из них требуется времени.
Данный подход, который называется профилированием, чреват несколькими проблемами:
    1. Прежде чем вы сможете сравнить алгоритмы, вы должны реализовать их оба.
    2.Результаты могут зависеть от того, какой компьютер вы используете. Один алгоритм хорошо работает на
      одной машине, второй — на другой.
    3.Результаты могут зависеть от размера задачи или данных, предоставленных в качестве входных.

Некоторые из этих задач можно решить с помощью анализа алгоритмов. В процессе своей работы он позволяет сравнивать
алгоритмы, не касаясь их реализации. Но мы должны ввести некоторые допущения:
    1.Чтобы избежать работы с элементами компьютерного оборудования, мы обычно определяем основные операции, которые
      составляют алгоритм (такие как сложение, умножение и сравнение чисел), и подсчитываем количество операций,
      требуемых каждому алгоритму.
    2.Лучший вариант обойти необходимость работать с элементами входных данных — провести анализ предполагаемой средней
      производительности входов. Если это невозможно, то в качестве простой альтернативы подойдет анализ наихудшего сценария.
    3.Наконец, возможно, что один алгоритм лучше всего подходит для небольших задач, а другой — для объемных. В этом
      случае мы обычно фокусируемся на последних, так как для небольших задач разница, вероятно, не имеет значения, но
      для больших она может быть огромной.

------------------------------------------------------------------------------------------------------------------------
Большинство простых алгоритмов относятся к нескольким категориям:

    O(1) Алгоритм относится к алгоритму постоянного времени, если время выполнения не зависит от размера ввода. Например,
    при наличии массива из n элементов и применении оператора скобок ([]) для доступа к одному из элементов
    потребуется одинаковое количество операций независимо от величины массива.

    O(n) Линейным алгоритм является, если время выполнения пропорционально размеру ввода. Так, для суммирования элементов
    массива нужно получить доступ к n элементам и выполнить n – 1 сложений. Общее количество операций (доступа к элементам
    и сложения) составляет 2n – 1, что пропорционально n.

    O(n^2) Квадратичным алгоритм можно назвать при условии, что время выполнения пропорционально n2. Например, необходимо
    проверить, появляется ли какой-либо элемент в списке более одного раза. Простой алгоритм — сравнение каждого элемента
    со всеми остальными. Если есть n элементов и каждый сравнивается с другими n – 1 элементами, то общее количество
    сравнений равно n2 – n, что пропорционально n2 при возрастании n.

------------------------------------------------------------------------------------------------------------------------

*/