/**
 * Имея строку S длины n на входе, алгоритм составляет Z-массив, в котором Z[i] является длиной наибольшей подстроки,
 * которая начинается в S[i] и также является префиксом S. Далее мы будем называть такую строку подстрокой-префиксом.
 *
 * Вот пример Z-массива:
 *      Индекс массива:     0 1 2 3 4 5 6 7 8 9 10 11
 *      Строка S:     a a b c a a b x a a a print
 *      Z-массив:     X 1 0 0 3 1 0 0 2 2 1 0
 *
 * Z[1]: 1, потому что длина максимальной по размеру подстроки, начинающейся с этого символа и одновременно являющейся
 * префиксом S, равна 1 − «а».
 * Z[2]: 0, поскольку S[2] != S[1].
 * …
 * Z[4]: 3, потому что совпадают S[4:6] и S[0:2]: «aab».
 *
 * Как построить Z-массив?
 * Наивное решение с двумя вложенными циклами, из которых внешний проходит по символам строки, а внутренний ищет длину
 * наибольшей подстроки-префикса S, имеет квадратичную сложность. Как построить Z-массив за линейное время?
 *
 * Идея заключается в следующем: в течение работы алгоритма мы храним интервал [L, R] такой,
 * что 1 ≤ L ≤ i ≤ R, а S[L, R] − это самая правая подстрока-префикс S. На шаге i = 1 мы можем сосчитать L и R, просто
 * сравнив S[0…] и S[1…] (и заодно получив значение Z[1]).
 *
 * 1. Если i > R, то мы можем утверждать, что нет такой префиксной подстроки, которая начиналась бы до i и заканчивалась
 *    после i; если бы она существовала, интервал [L, R] был бы другой. Поэтому вычисляем новые L и R путем посимвольного
 *    сравнения S[0…] и S[i…]. Z[i] принимаем за R − L + 1.
 *
 * 2. Если же i ≤ R, то мы можем использовать уже вычисленные значения Z. Пусть K = i − L. Мы знаем, что Z[i] ≥ min(Z[K],
 *    R − i + 1), потому что S[i…] соответствует S[K…] по крайней мере в R − i + 1 символов (они находятся в [L, R],
 *    который, как мы знаем, является префиксной подстрокой).
 *        1. Если Z [K] < R − i + 1, то не существует более длинной префиксной подстроки, начинающейся с S[i]
 *           (иначе Z [K] был бы больше). Отсюда, Z[i] = Z[K] и интервал [L, R] остается таким же.
 *        2. Если Z[K] ≥ R − i + 1, то возможна ситуация, что S[0…] и S[i…] совпадают в более чем R − i + 1 символах.
 *           Так, нам нужно обновить интервал [L, R], положив L = i и проверив совпадения после S[R+1] для получения
 *           нового значения R. В процессе вычисляется значение Z[i].
 *
 * И где тут pattern searching?
 * Внимательный читатель заметит, что в алгоритме выше никак не фигурирует поиск паттернов. Для решения этой задачи
 * сделаем хитрость: составим новую строку Sn = P + $ + S, где P − паттерн; $ − символ-разделитель, который не встречается
 * ни в P, ни в S; S − исходная строка и вычислим Z-массив для Sn.
 *
 * Нетрудно заметить, что если Z[i] = length(P), то паттерн входит в эту строку начиная с символа i.
 *
 * */
package algorithms.z_function_string;